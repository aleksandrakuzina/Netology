### Задача 1.

#### Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

#### Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

#### Вы как инженер поддержки решили произвести данную операцию:

 * напишите список операций, которые вы будете производить для остановки запроса пользователя
 * предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
> 1. Необходимо отфильтровать CRUD операции в MongoDB которые превышают 3 мин.

```
db.currentOp().inprog.forEach(
	  function(op) {
	    if(op.secs_running > 180) printjson(op);
	  }
	)
```
> 2. Прервать операцию можно с помощью метода db.killOp(<opid>) (Завершает операцию в соответствии с идентификатором операции)

> db.killOp(<opid>)

* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

> В документации есть метод  maxTimeMS(), который может стать решением при долгих зависающих запросах и сможет ограничить по времени операцию выполнения:

> Метод maxTimeMS()устанавливает ограничение по времени для операции. Когда операция достигает указанного срока, MongoDB прерывает операцию в следующей точке прерывания.

### Задача 2.
#### Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

#### Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

#### При масштабировании сервиса до N реплик вы увидели, что:

* сначала рост отношения записанных значений к истекшим

> Данные в redis читаются по определенным ключам, которые все время записываются в Redis и будут занимать все больше и больше места в оперативной памяти. Нам нужно удалять нерелевантные данные поэтому добавляется к каждому ключу TTL (время жизни ключа).

> Т.к. в задании как раз сказано, что сервис использует TTL -механизм, то можно предположить, что при увеличении (масштабировании) до N-реплик новые значения key-value с TTL ключом сначала превысят истекшие, т.к. TTL новых значений (которые увеличатся при масштабировании)только-только начнут отсчет, через время новые и истекшие уравновесятся.  

> Поэтому в момент появления N-реплики, количество истекших было пропорционально N-1 реплики.
  
* Redis блокирует операции записи
* Как вы думаете, в чем может быть проблема?

> Блокировка записи может быть вызвана процессом сброса буфера записи на диск, а также большим количеством удаляемых ключей - операция записи блокируется до завершения процесса удаления ключей.

 
### Задача 3

#### Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '

* Как вы думаете, почему это начало происходить и как локализовать проблему?
* Какие пути решения данной проблемы вы можете предложить?

> Ошибка вида (InterfaceError) 2013 показывает:
> Потеряно соединение с сервером MySQL
>Т.к. по заданию БД поднято для использования в гис-системе, то предпологается увеличение объема информации и возможно не хватает времени системе отдать эти данные клиентской стороне. 
увеличилось количество обрабатываемой информации и это можно решить увеличением timeoute. 
Следует попробовать увеличить значение net_read_timeout с 30 секунд по умолчанию до 60 секунд или более, достаточного для завершения передачи данных.

### Задача 4

#### Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

#### После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

* postmaster invoked oom-killer
* Как вы думаете, что происходит?
* Как бы вы решили данную проблему?

> postmaster invoked oom-killer - это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС. OOM-Killer вызывает функцию oom_kill_task(). Эта функция отправляет процессу сигнал завершения. В случае нехватки памяти oom_kill() вызывает эту функцию, чтобы отправить процессу сигнал SIGKILL
> 
> Если в dmesg наблюдается процесс OOM Killer и невозможно настроить postgres для использования меньшего количества памяти, нужно либо получить больше оперативной памяти, либо (если дождаться завершения процесса) добавить подкачку (swap на жесткий диск), пока ядро не будет удовлетворено.